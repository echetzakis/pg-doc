const { version } = require('./package.json');

function writeDoc(context) {
    header(context);
    toc(context);
    details(context);
    footer(context);
}

function header({ stream }) {
    stream.write('# Database Documentation\n');
}

function toc({ stream, tables }) {
    let i = 1;
    const names = Object.keys(tables).sort();
    let initial = names[0][0].toUpperCase();
    const splitByInitial = names.length > 20;
    stream.write('## Tables \n');
    if (splitByInitial) {
        stream.write(names.map(name => name[0].toUpperCase()).reduce((initials, letter) => {
            if (!initials.includes(letter)) {
                initials.push(letter);
            }
            return initials;
        }, []).map(initial => `[${initial}](#${initial})`).join(' \\| '));
        stream.write('\n');
    }
    tocHeader(stream, splitByInitial, initial);
    names.forEach(name => {
        let newInitial = name[0].toUpperCase();
        if (initial !== newInitial && splitByInitial) {
            initial = newInitial;
            tocHeader(stream, splitByInitial, initial);
        }
        stream.write(`|${i}| [${name}](#${name}) | ${tables[name].description} |\n`);
        i++;
    });
}

function tocHeader(stream, splitByInitial, initial) {
    if (splitByInitial) {
        stream.write(`### ${initial} \n`);
    }
    stream.write('|\# |Table Name| Description|\n');
    stream.write('|--:|----------|------------|\n');
}

function details({ stream, tables, columns, constraints }) {
    stream.write('## Details \n');
    for (table in tables) {
        stream.write(`### ${table}\n`);
        stream.write(`${tables[table].description}\n`);
        stream.write('|\# |column|type|nullable|default|constraints|description|\n');
        stream.write('|--:|------|----|--------|-------|-----------|-----------|\n');
        columnDetails({ stream, columns: columns[table] || {}, constraints: constraints[table] || {} })
    }
}

function columnDetails({ stream, columns, constraints }) {
    let i = 1;
    for (name in columns) {
        const data = columns[name];
        stream.write(`| ${i} | ${name} |  ${data.type} | ${data.nullable} | ${mdEsc(data.default)} | ${constraintDetails(constraints[name])} | ${mdEsc(data.description)} |\n`);
        i++;
    }
}

function constraintDetails(constraints) {
    if (!constraints) {
        return '';
    }
    let constraintData = [];
    if (constraints) {
        if (constraints.pk) {
            constraintData.push('**PK**');
        }
        if (constraints.unq) {
            constraintData.push('**UNIQ**');
        }
        if (constraints.fk) {
            constraintData.push(`**FK** \([${constraints.fk.table}.${constraints.fk.column}](#${constraints.fk.table})\)`);
        }
    }
    return constraintData.join(', ');
}

function mdEsc(str) {
    if (!str) {
        return '';
    }
    return str.replace(/\|/g, '\\$&');
}

function footer({ stream }) {
    stream.write('---\n');
    stream.write(`generated by [pg-doc](https://github.com/echetzakis/pg-doc) v${version}\n`);
    stream.end();
}

module.exports = writeDoc;
